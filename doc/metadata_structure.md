# IdeaBase 元数据结构设计

## 核心设计理念

IdeaBase的元数据系统采用了一种扁平化的字典存储结构，通过key-value映射高效管理类和字段信息，并通过严格的命名规范化策略避免重复字段的产生。

## 元数据内存结构

### Metadata 核心结构

```go
type Metadata struct {
    k   *std.Konfig          // 配置管理器
    db  *gorm.DB             // 数据库连接
    cfg *internal.Config     // 元数据配置

    // 统一索引: 支持类名、表名、原始表名查找
    Nodes   map[string]*internal.Class  // 类信息映射
    Version string                      // 元数据版本
}
```

### 类和字段的存储方式

1. **类存储** - `Nodes` 字段使用 `map[string]*internal.Class` 结构
   - Key: 类名/表名（统一转换为标准格式）
   - Value: 类信息指针
   - **重要特点**：类名和表名作为两个不同的key，但它们指向同一个类信息对象指针。这意味着可以通过任一名称访问相同的类信息。

2. **字段存储** - 每个类中的 `Fields` 字段使用 `map[string]*internal.Field` 结构
   - Key: 字段名/列名（统一转换为标准格式）
   - Value: 字段信息指针
   - **重要特点**：字段名和列名作为两个不同的key，但它们指向同一个字段信息对象指针，实现了双索引访问。

### 索引优化策略

为了避免冗余和提高访问效率，系统采用了以下索引优化策略：

1. **单一源指针**：尽管有多个key，但所有key指向的是同一个对象指针，避免了数据冗余和不一致性。

2. **可选的规范化策略**：
   - 当需要进行名称规范化时（如驼峰命名转换），保留双索引以支持多种访问方式。
   - 如果不需要名称规范化，可以仅使用表名和列名作为key，简化索引结构。

3. **索引加载优化**：
   - 在索引加载时，可以直接使用表名或列名作为主索引。
   - 找到类信息后，再通过类信息获取类名或者表名。
   - 找到字段信息后，再通过字段信息获取字段名或者列名。
   - 这样可以避免在索引加载时进行不必要的命名转换，直接从信息中获取一致的名称。

## 命名规范化策略

为避免重复字段，系统采用了以下命名规范化策略：

1. **类名和表名转换**
   - 数据库表名转换为GraphQL类型名时使用单数大驼峰命名法

2. **字段名和列名转换**
   - 数据库列名转换为GraphQL字段名时使用小驼峰命名法

## 重复字段处理策略

在处理关系时，为避免生成重复字段，系统采用以下策略：

1. **预处理清理**
   - 在处理关系前，先清理所有虚拟字段，确保没有遗留
   - 通过 `cleanupVirtualFields` 方法实现

2. **两阶段关系处理**
   - 第一阶段：收集所有类之间的关系信息
   - 第二阶段：创建规范化的关系字段，确保唯一性

3. **字段名唯一性确保**
   - 跟踪已创建的字段，避免重复
   - 当发现冲突时，跳过创建或使用替代名称

4. **关系类型处理**
   - 对于不同类型的关系（一对多、多对一、多对多）使用不同的命名模式
   - 例如：对于多对一关系，同时创建正向和反向关系字段

## 关键代码实现

### 关系处理核心逻辑

```go
// 跟踪已创建的字段，避免重复 - map[className]map[标准化字段名]fieldName
createdFields := make(map[string]map[string]string)
for className := range my.Nodes {
    createdFields[className] = make(map[string]string)
}

// 处理所有关系创建字段
for key := range relationFields {
    // ... 生成字段名和类型逻辑 ...
    
    // 检查该类中是否已存在标准化后同名的字段
    if existingField, exists := createdFields[key.sourceClass][fieldName]; exists {
        // 已存在同名字段，跳过创建
        log.Debug().
            Str("class", key.sourceClass).
            Str("fieldName", fieldName).
            Str("existingField", existingField).
            Msg("跳过创建重复字段")
        continue
    }

    // 确保字段名在类中唯一
    fieldName = my.getUniqueFieldName(sourceClass, fieldName)

    // 创建关系字段
    sourceClass.Fields[fieldName] = &internal.Field{
        // ... 字段属性设置 ...
    }

    // 记录已创建的字段
    createdFields[key.sourceClass][fieldName] = fieldName
}

## 设计优势

1. **高效查找** - 通过map结构实现O(1)复杂度的类和字段查找
2. **避免重复** - 通过统一的命名规范和标准化比较策略避免重复字段
3. **关系完整性** - 自动创建反向关系，确保数据模型的完整性
4. **扩展性** - 结构清晰，易于添加新的元数据特性和关系类型

## 潜在问题和解决方案

1. **大小写敏感性**
   - 问题：数据库可能有大小写不同但语义相同的字段
   - 解决：使用小写比较策略进行字段名规范化

2. **多表关系冲突**
   - 问题：同一个表可能有多个关系字段指向相同的目标表
   - 解决：使用更精确的标准化规则，包含源字段和目标字段信息

3. **虚拟字段冲突**
   - 问题：配置文件定义的虚拟字段可能与自动生成的冲突
   - 解决：优先保留用户配置的字段，自动生成时进行检查

4. **双索引维护成本**
   - 问题：维护类名/表名和字段名/列名的双索引可能增加复杂性
   - 解决：严格遵循"单一源指针"原则，确保任何修改都同步到所有索引指向的对象

## 最佳实践

1. 在处理关系前，始终先清理所有虚拟字段
2. 使用标准化的字段名进行比较和索引
3. 保持命名规范的一致性，避免混合使用不同的命名风格
4. 记录已创建的字段，避免重复创建
5. 优先使用配置文件中定义的字段，避免自动覆盖
6. 根据应用场景选择适当的索引策略，对于简单应用可以仅使用表名和列名作为索引
7. 在创建关系字段时，确保检查所有可能的字段命名形式，避免因命名变体导致的重复
